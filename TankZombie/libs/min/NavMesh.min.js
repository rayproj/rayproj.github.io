var NavMesh;!function(NavMesh){class Astar{static init(graph){for(let x=0;x<graph.length;x++){let node=graph[x];node.f=0,node.g=0,node.h=0,node.cost=1,node.visited=!1,node.closed=!1,node.parent=null}}static cleanUp(graph){for(let x=0;x<graph.length;x++){let node=graph[x];delete node.f,delete node.g,delete node.h,delete node.cost,delete node.visited,delete node.closed,delete node.parent}}static heap(){return new NavMesh.BinaryHeap(function(node){return node.f})}static search(graph,start,end){Astar.init(graph);let openHeap=Astar.heap();for(openHeap.push(start);openHeap.size()>0;){let currentNode=openHeap.pop();if(currentNode===end){let curr=currentNode,ret=[];for(;curr.parent;)ret.push(curr),curr=curr.parent;return this.cleanUp(ret),ret.reverse()}currentNode.closed=!0;let neighbours=Astar.neighbours(graph,currentNode);for(let i=0,il=neighbours.length;i<il;i++){let neighbour=neighbours[i];if(neighbour.closed)continue;let gScore=currentNode.g+neighbour.cost,beenVisited=neighbour.visited;(!beenVisited||gScore<neighbour.g)&&(neighbour.visited=!0,neighbour.parent=currentNode,!neighbour.centroid||end.centroid,neighbour.h=neighbour.h||Astar.heuristic(neighbour.centroid,end.centroid),neighbour.g=gScore,neighbour.f=neighbour.g+neighbour.h,beenVisited?openHeap.rescoreElement(neighbour):openHeap.push(neighbour))}}return[]}static heuristic(pos1,pos2){return NavMesh.Vector3.distanceToSquared(pos1,pos2)}static neighbours(graph,node){let ret=[];for(let e=0;e<node.neighbours.length;e++)ret.push(graph[node.neighbours[e]]);return ret}}NavMesh.Astar=Astar}(NavMesh||(NavMesh={})),function(NavMesh){NavMesh.BinaryHeap=class{constructor(scoreFunction){this.content=[],this.scoreFunction=scoreFunction}push(element){this.content.push(element),this.sinkDown(this.content.length-1)}pop(){let result=this.content[0],end=this.content.pop();return this.content.length>0&&(this.content[0]=end,this.bubbleUp(0)),result}remove(node){let i=this.content.indexOf(node),end=this.content.pop();i!==this.content.length-1&&(this.content[i]=end,this.scoreFunction(end)<this.scoreFunction(node)?this.sinkDown(i):this.bubbleUp(i))}size(){return this.content.length}rescoreElement(node){this.sinkDown(this.content.indexOf(node))}sinkDown(n){let element=this.content[n];for(;n>0;){let parentN=(n+1>>1)-1,parent=this.content[parentN];if(!(this.scoreFunction(element)<this.scoreFunction(parent)))break;this.content[parentN]=element,this.content[n]=parent,n=parentN}}bubbleUp(n){let length=this.content.length,element=this.content[n],elemScore=this.scoreFunction(element);for(;;){let child1Score,child2N=n+1<<1,child1N=child2N-1,swap=null;if(child1N<length){let child1=this.content[child1N];(child1Score=this.scoreFunction(child1))<elemScore&&(swap=child1N)}if(child2N<length){let child2=this.content[child2N];this.scoreFunction(child2)<(null===swap?elemScore:child1Score)&&(swap=child2N)}if(null===swap)break;this.content[n]=this.content[swap],this.content[swap]=element,n=swap}}}}(NavMesh||(NavMesh={})),function(NavMesh){NavMesh.Channel=class{constructor(){this.portals=[]}push(p1,p2){void 0===p2&&(p2=p1),this.portals.push({left:p1,right:p2})}triarea2(a,b,c){var ax=b.x-a.x,az=b.z-a.z;return(c.x-a.x)*az-ax*(c.z-a.z)}vequal(a,b){return NavMesh.Vector3.distanceToSquared(a,b)<1e-5}stringPull(){let portalApex,portalLeft,portalRight,portals=this.portals,pts=[],apexIndex=0,leftIndex=0,rightIndex=0;portalApex=portals[0].left,portalLeft=portals[0].left,portalRight=portals[0].right,pts.push(portalApex);for(let i=1;i<portals.length;i++){let left=portals[i].left,right=portals[i].right;if(this.triarea2(portalApex,portalRight,right)<=0){if(!(this.vequal(portalApex,portalRight)||this.triarea2(portalApex,portalLeft,right)>0)){pts.push(portalLeft),portalLeft=portalApex=portalLeft,portalRight=portalApex,leftIndex=apexIndex=leftIndex,rightIndex=apexIndex,i=apexIndex;continue}portalRight=right,rightIndex=i}if(this.triarea2(portalApex,portalLeft,left)>=0){if(!(this.vequal(portalApex,portalLeft)||this.triarea2(portalApex,portalRight,left)<0)){pts.push(portalRight),portalLeft=portalApex=portalRight,portalRight=portalApex,leftIndex=apexIndex=rightIndex,rightIndex=apexIndex,i=apexIndex;continue}portalLeft=left,leftIndex=i}}return 0!==pts.length&&this.vequal(pts[pts.length-1],portals[portals.length-1].left)||pts.push(portals[portals.length-1].left),this.path=pts,pts}}}(NavMesh||(NavMesh={})),function(NavMesh){NavMesh.Face=class{constructor(a,b,c){this.a=0,this.b=0,this.c=0,this.c=c,this.b=b,this.a=a}}}(NavMesh||(NavMesh={})),function(NavMesh){NavMesh.Geometry=class{constructor(){this.faces=[],this.vertices=[]}mergeVertices(){let v,key,i,il,face,indices,verticesMap={},unique=new Array,changes=[],precision=Math.pow(10,4);for(i=0,il=this.vertices.length;i<il;i++)v=this.vertices[i],null==verticesMap[key=Math.round(v.x*precision)+"_"+Math.round(v.y*precision)+"_"+Math.round(v.z*precision)]?(verticesMap[key]=i,unique.push(v),changes[i]=unique.length-1):changes[i]=changes[verticesMap[key]];let faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){(face=this.faces[i]).a=changes[face.a],face.b=changes[face.b],face.c=changes[face.c],indices=[face.a,face.b,face.c];let dupIndex=-1;for(let n=0;n<3;n++)if(indices[n]==indices[(n+1)%3]){dupIndex=n,faceIndicesToRemove.push(i);break}}for(i=faceIndicesToRemove.length-1;i>=0;i--){let idx=faceIndicesToRemove[i];this.faces.splice(idx,1)}let diff=this.vertices.length-unique.length;return this.vertices=unique,diff}}}(NavMesh||(NavMesh={})),function(NavMesh){function buildNodes(geometry){let navigationMesh=NavMesh.Patroll.buildNavigationMesh(geometry);return NavMesh.Patroll.groupNavMesh(navigationMesh)}NavMesh.zoneNodes={},NavMesh.buildNodesByJson=function(json){let p2=json.vertices,ii=json.faces,faces=[];for(let i=0;i<ii.length/5;i++)faces.push(new NavMesh.Face(ii[5*i+1],ii[5*i+2],ii[5*i+3]));let p=[];for(let i=0;i<p2.length;i+=3)p.push(new NavMesh.Vector3(p2[i],p2[i+1],p2[i+2]));let g=new NavMesh.Geometry;return g.faces=faces,g.vertices=p,buildNodes(g)},NavMesh.buildNodes=buildNodes,NavMesh.setZoneData=function(zone,data){NavMesh.zoneNodes[zone]=data},NavMesh.getGroup=function(zone,position){if(!NavMesh.zoneNodes[zone])return null;let closestNodeGroup=null,distance=Math.pow(50,2);for(let i=0,len=NavMesh.zoneNodes[zone].groups.length;i<len;i++){const group=NavMesh.zoneNodes[zone].groups[i];for(let j=0,len2=group.length;j<len2;j++){const node=group[j];let measuredDistance=NavMesh.Vector3.distanceToSquared(node.centroid,position);measuredDistance<distance&&(closestNodeGroup=i,distance=measuredDistance)}}return closestNodeGroup},NavMesh.getRandomNode=function(zone,group,nearPosition,nearRange){if(!NavMesh.zoneNodes[zone])return new NavMesh.Vector3;nearPosition=nearPosition||null,nearRange=nearRange||0;let candidates=[],polygons=NavMesh.zoneNodes[zone].groups[group];for(let i=0,len=polygons.length;i<len;i++){const p=polygons[i];nearPosition&&nearRange?NavMesh.Vector3.distanceToSquared(nearPosition,p.centroid)<nearRange*nearRange&&candidates.push(p.centroid):candidates.push(p.centroid)}if(candidates.length>0){let index=NavMesh.random(candidates.length);return candidates[index],candidates[index]}},NavMesh.findPath=function(startPosition,targetPosition,zone,group){let allNodes=NavMesh.zoneNodes[zone].groups[group],vertices=NavMesh.zoneNodes[zone].vertices,closestNode=null,distance=Math.pow(50,2);for(let i=0,len=allNodes.length;i<len;i++){const node=allNodes[i];let measuredDistance=NavMesh.Vector3.distanceToSquared(node.centroid,startPosition);measuredDistance<distance&&(closestNode=node,distance=measuredDistance)}let farthestNode=null;distance=Math.pow(50,2);for(let i=0,len=allNodes.length;i<len;i++){const node=allNodes[i];let measuredDistance=NavMesh.Vector3.distanceToSquared(node.centroid,targetPosition);measuredDistance<distance&&NavMesh.Vector3.isVectorInPolygon(targetPosition,node,vertices)&&(farthestNode=node,distance=measuredDistance)}if(!closestNode||!farthestNode)return null;let paths=NavMesh.Astar.search(allNodes,closestNode,farthestNode),getPortalFromTo=function(a,b){for(let i=0;i<a.neighbours.length;i++)if(a.neighbours[i]===b.id)return a.portals[i]},channel=new NavMesh.Channel;channel.push(startPosition);for(let i=0;i<paths.length;i++){let polygon=paths[i],nextPolygon=paths[i+1];if(nextPolygon){let portals=getPortalFromTo(polygon,nextPolygon);channel.push(vertices[portals[0]],vertices[portals[1]])}}channel.push(targetPosition),channel.stringPull();let threeVectors=[];for(let i=0,len=channel.path.length;i<len;i++){const c=channel.path[i];let vec=new NavMesh.Vector3(c.x,c.y,c.z),contain=!1;for(let g=0;g<threeVectors.length;g++){let vec0=threeVectors[g];if(Math.abs(vec0.x-vec.x)<=.01&&Math.abs(vec0.y-vec.y)<=.01&&Math.abs(vec0.z-vec.z)<=.01){contain=!0;break}}contain||threeVectors.push(vec)}return threeVectors.shift(),threeVectors}}(NavMesh||(NavMesh={})),function(NavMesh){class Patroll{static computeCentroids(geometry){let f,fl,face;for(f=0,fl=geometry.faces.length;f<fl;f++)(face=geometry.faces[f]).centroid=new NavMesh.Vector3(0,0,0),NavMesh.Vector3.add(face.centroid,geometry.vertices[face.a],face.centroid),NavMesh.Vector3.add(face.centroid,geometry.vertices[face.b],face.centroid),NavMesh.Vector3.add(face.centroid,geometry.vertices[face.c],face.centroid),NavMesh.Vector3.scale(face.centroid,1/3,face.centroid)}static buildNavigationMesh(geometry){return Patroll.computeCentroids(geometry),geometry.mergeVertices(),Patroll.buildPolygonsFromGeometry(geometry)}static buildPolygonsFromGeometry(geometry){let polygons=[],vertices=geometry.vertices;for(let i=0,len=geometry.faces.length;i<len;i++){let face=geometry.faces[i];polygons.push({id:Patroll.polygonId++,vertexIds:[face.a,face.b,face.c],centroid:face.centroid,normal:face.normal,neighbours:[]})}let navigationMesh={polygons:polygons,vertices:vertices};for(let i=0,len=polygons.length;i<len;i++){let polygon=polygons[i];Patroll.buildPolygonNeighbours(polygon,navigationMesh)}return navigationMesh}static buildPolygonNeighbours(polygon,navigationMesh){polygon.neighbours=[];for(let i=0,len=navigationMesh.polygons.length;i<len;i++){if(polygon===navigationMesh.polygons[i])continue;if(NavMesh.Vector3.distanceToSquared(polygon.centroid,navigationMesh.polygons[i].centroid)>1e4)continue;Patroll.arrayIntersect(polygon.vertexIds,navigationMesh.polygons[i].vertexIds).length>=2&&polygon.neighbours.push(navigationMesh.polygons[i])}}static arrayIntersect(...params){let i,shortest,nShortest,n,len,nOthers,ret=[],obj={};for(nOthers=params.length-1,nShortest=params[0].length,shortest=0,i=0;i<=nOthers;i++)(n=params[i].length)<nShortest&&(shortest=i,nShortest=n);for(i=0;i<=nOthers;i++){len=params[n=i===shortest?0:i||shortest].length;for(let j=0;j<len;j++){let elem=params[n][j];obj[elem]===i-1?i===nOthers?(ret.push(elem),obj[elem]=0):obj[elem]=i:0===i&&(obj[elem]=0)}}return ret}static groupNavMesh(navigationMesh){let saveObj={vertices:null,groups:null};for(let i=0,len=navigationMesh.vertices.length;i<len;i++){let vertice=navigationMesh.vertices[i];vertice.x=Patroll.roundNumber(vertice.x,2),vertice.y=Patroll.roundNumber(vertice.y,2),vertice.z=Patroll.roundNumber(vertice.z,2)}saveObj.vertices=navigationMesh.vertices;let groups=Patroll.buildPolygonGroups(navigationMesh);saveObj.groups=[];let findPolygonIndex=function(group,p){for(let i=0;i<group.length;i++)if(p===group[i])return i};for(let i=0,len=groups.length;i<len;i++){const group=groups[i];let newGroup=[];for(let j=0,len2=group.length;j<len2;j++){const p=group[j];let neighbours=[],portals=[];for(let z=0,len3=p.neighbours.length;z<len3;z++){const n=p.neighbours[z];neighbours.push(findPolygonIndex(group,n)),portals.push(Patroll.getSharedVerticesInOrder(p,n))}p.centroid.x=Patroll.roundNumber(p.centroid.x,2),p.centroid.y=Patroll.roundNumber(p.centroid.y,2),p.centroid.z=Patroll.roundNumber(p.centroid.z,2),newGroup.push({id:findPolygonIndex(group,p),neighbours:neighbours,vertexIds:p.vertexIds,centroid:p.centroid,portals:portals})}saveObj.groups.push(newGroup)}return saveObj}static getSharedVerticesInOrder(a,b){let aList=a.vertexIds,bList=b.vertexIds,sharedVertices=[];for(let i=0,len=aList.length;i<len;i++){const vId=aList[i];bList.indexOf(vId)>-1&&sharedVertices.push(vId)}if(sharedVertices.length<2)return[];sharedVertices.indexOf(aList[0])>-1&&sharedVertices.indexOf(aList[aList.length-1])>-1&&aList.push(aList.shift()),sharedVertices.indexOf(bList[0])>-1&&sharedVertices.indexOf(bList[bList.length-1])>-1&&bList.push(bList.shift()),sharedVertices=[];for(let i=0,len=aList.length;i<len;i++){const vId=aList[i];bList.indexOf(vId)>-1&&sharedVertices.push(vId)}return sharedVertices}static buildPolygonGroups(navigationMesh){let polygons=navigationMesh.polygons,polygonGroups=(navigationMesh.vertices,[]),groupCount=0;function spreadGroupId(polygon){for(let i=0,len=polygon.neighbours.length;i<len;i++){const neighbour=polygon.neighbours[i];null==neighbour.group&&(neighbour.group=polygon.group,spreadGroupId(neighbour))}}for(let i=0,len=polygons.length;i<len;i++){const polygon=polygons[i];null==polygon.group&&(polygon.group=groupCount++,spreadGroupId(polygon)),polygonGroups[polygon.group]||(polygonGroups[polygon.group]=[]),polygonGroups[polygon.group].push(polygon)}return polygonGroups}static roundNumber(number,decimals){let newnumber=new Number(number+"").toFixed(decimals);return parseFloat(newnumber)}}Patroll.polygonId=1,NavMesh.Patroll=Patroll}(NavMesh||(NavMesh={})),function(NavMesh){NavMesh.random=function(n,t=null){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))}}(NavMesh||(NavMesh={})),function(NavMesh){class Vector3{constructor(x=0,y=0,z=0,nativeElements=null){this.x=x,this.y=y,this.z=z}static add(a,b,out){out.x=a.x+b.x,out.y=a.y+b.y,out.z=a.z+b.z}static subtract(a,b,o){o.x=a.x-b.x,o.y=a.y-b.y,o.z=a.z-b.z}static cross(a,b,o){let ax=a.x,ay=a.y,az=a.z,bx=b.x,by=b.y,bz=b.z;o.x=ay*bz-az*by,o.y=az*bx-ax*bz,o.z=ax*by-ay*bx}static dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z}static scalarLength(a){let x=a.x,y=a.y,z=a.z;return Math.sqrt(x*x+y*y+z*z)}static scalarLengthSquared(a){let x=a.x,y=a.y,z=a.z;return x*x+y*y+z*z}static normalize(s,out){let x=s.x,y=s.y,z=s.z,len=x*x+y*y+z*z;len>0&&(len=1/Math.sqrt(len),out.x=x*len,out.y=y*len,out.z=z*len)}static multiply(a,b,out){out.x=a.x*b.x,out.y=a.y*b.y,out.z=a.z*b.z}static scale(a,b,out){out.x=a.x*b,out.y=a.y*b,out.z=a.z*b}static lerp(a,b,t,out){let ax=a.x,ay=a.y,az=a.z;out.x=ax+t*(b.x-ax),out.y=ay+t*(b.y-ay),out.z=az+t*(b.z-az)}static distanceToSquared(a,b){let dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z;return dx*dx+dy*dy+dz*dz}static isVectorInPolygon(vector,polygon,vertices){polygon.centroid;let lowestPoint=1e5,highestPoint=-1e5,polygonVertices=[];for(let i=0,len=polygon.vertexIds.length;i<len;i++){const vId=polygon.vertexIds[i];lowestPoint=Math.min(vertices[vId].y,lowestPoint),highestPoint=Math.max(vertices[vId].y,highestPoint),polygonVertices.push(vertices[vId])}return!!(vector.y<highestPoint+.5&&vector.y>lowestPoint-.5&&Vector3.isPointInPoly(polygonVertices,vector))}static isPointInPoly(poly,pt){for(var c=!1,i=-1,l=poly.length,j=l-1;++i<l;j=i)(poly[i].z<=pt.z&&pt.z<poly[j].z||poly[j].z<=pt.z&&pt.z<poly[i].z)&&pt.x<(poly[j].x-poly[i].x)*(pt.z-poly[i].z)/(poly[j].z-poly[i].z)+poly[i].x&&(c=!c);return c}cloneTo(destObject){let destVector3=destObject;destVector3.x=this.x,destVector3.y=this.y,destVector3.z=this.z}clone(){let destVector3=new Vector3;return this.cloneTo(destVector3),destVector3}}NavMesh.Vector3=Vector3}(NavMesh||(NavMesh={}));