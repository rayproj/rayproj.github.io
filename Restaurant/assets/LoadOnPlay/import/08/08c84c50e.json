[1,["82rmFjUGRMYL09qvUQGf7l","84BXhfyD1BObYzEYGtyMkM@f9941","32bBWn6Y1Jla5iVpOLVHW2@f9941","bf+NDTsYNFRaEWXbBj5psS@f9941","74mrBLWlVCaLN/jMWGjN/4@6c48a","0dTC9LjulJyIWBD/7ffwI5@6c48a","32bBWn6Y1Jla5iVpOLVHW2@6c48a","4a2RW2QyBDVJ0oPsH98zhw@6c48a","53ijiek1hL/rvhqX1LlaPw@6c48a","72NW5wUepC2I/1QEChJq4r@6c48a","73BOIQq49E17BXX4hycxen@6c48a","770eSFlaJABqwtWRDLmIvi@6c48a","84BXhfyD1BObYzEYGtyMkM@6c48a","ab4SjBtkRGAITy5MkVcHsE@6c48a","39+QbIGilAf5rnbxnmqZ9g","70fyylBIBA5YxlttuPBksQ@f9941","53ijiek1hL/rvhqX1LlaPw@f9941","4a2RW2QyBDVJ0oPsH98zhw@f9941","72NW5wUepC2I/1QEChJq4r@f9941","d953D0uKVLeIIydyfBOj3i@f9941","0dTC9LjulJyIWBD/7ffwI5@f9941","e1wzgZr1JB0qFXrTyjI3SU@f9941","e2wRRwHlJBu5neyypMjYoS@f9941","ab4SjBtkRGAITy5MkVcHsE@f9941","beo2jeHV5GSpBLzZubulFk","73BOIQq49E17BXX4hycxen@f9941","d7cxsJ+1NFTJjGh8fZLGtO@f9941","e61PszyktEqoAC/RXBdm8x@f9941","bdizI1rulBW615CYIGsLNW","12Y9dMgWdJKJGmTiZyQR9H@2e76e","770eSFlaJABqwtWRDLmIvi@f9941","47tApSf4RIX7tc0vg9rRO1","d7cxsJ+1NFTJjGh8fZLGtO@6c48a","d953D0uKVLeIIydyfBOj3i@6c48a","e1wzgZr1JB0qFXrTyjI3SU@6c48a","e2wRRwHlJBu5neyypMjYoS@6c48a","e61PszyktEqoAC/RXBdm8x@6c48a"],["node","_spriteFrame","_textureSource","_font","_parent","root","tempContent","pageNode","pagePointCom","pageList","foodNumProgress","typeLab","typeIcon","foodAllNumLab","foodNumLab","typeName","itemLayout","foodItem","_target","target","nameLabel","icon","featureIcon","selectedFlag","_barSprite","_content","data","mCamera","asset","_normalSprite","_mesh","mainTex","secTex","_effectAsset"],["cc.SpriteFrame",["cc.Node",["_name","_layer","_objFlags","__editorExtras__","_active","_prefab","_components","_parent","_lpos","_children","_lscale"],-2,4,9,1,5,2,5],["cc.Node",["_name","_layer","_objFlags","_active","_components","_prefab","_parent","_lpos","_children","_lrot","_lscale","_euler"],-1,12,4,1,5,2,5,5,5],["cc.Sprite",["_type","_sizeMode","_fillRange","node","__prefab","_spriteFrame"],0,1,4,6],["cc.Label",["_string","_actualFontSize","_isSystemFontUsed","_cacheMode","_fontSize","_lineHeight","_overflow","node","__prefab","_color","_font"],-4,1,4,5,6],["cc.UITransform",["node","__prefab","_contentSize","_anchorPoint"],3,1,4,5,5],["cc.Button",["_transition","node","__prefab","clickEvents","_hoverColor","_pressedColor","_target","_normalSprite"],2,1,4,9,5,5,1,6],["cc.Layout",["_layoutType","_spacingX","_paddingTop","_spacingY","_resizeMode","node","__prefab"],-2,1,4],["cc.PrefabInfo",["fileId","root","asset","nestedPrefabInstanceRoots"],2,1,1,2],["cc.Widget",["_alignFlags","_originalWidth","_right","_originalHeight","node","__prefab"],-1,1,4],["cc.ClickEvent",["_componentId","handler","target"],1,1],["cc.Mesh",["_native","_hash","_struct"],1,11],["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Prefab",["_name"],2],["cc.Node",["_name","_layer","_parent","_components","_prefab","_lpos"],1,1,2,4,5],["cc.CompPrefabInfo",["fileId"],2],["067d6qZTBxMIK509mU2brrC",["node","__prefab"],3,1,4],["3cf5dK5T/pOha3nl0sjO8St",["autoRelease","node","__prefab","foodItem","itemLayout","typeName","foodNumLab","foodAllNumLab","typeIcon","typeLab","foodNumProgress","pageList","pagePointCom","pageNode","tempContent"],2,1,4,1,1,1,1,1,1,1,1,1,1,1,1],["cc.PrefabInfo",["fileId","root","instance","asset"],2,1,4,6],["cbfedIJ1bRFDJgsZP/HNzzU",["node","__prefab"],3,1,4],["db5e5YnM+5IiJycJF6Y0BE/",["node","__prefab","featureIcon","icon","nameLabel"],3,1,4,1,1,1],["e08b34SG0lKl53dUW6g28iC",["selectedMode","node","__prefab","selectedFlag"],2,1,4,1],["cc.ProgressBar",["_enabled","_totalLength","_progress","node","__prefab","_barSprite"],0,1,4,1],["cc.ScrollView",["bounceDuration","brake","elastic","vertical","node","__prefab","_content"],-1,1,4,1],["cc.Mask",["node","__prefab"],3,1,4],["cc.MeshRenderer",["_name","node","__prefab","_materials","lightmapSettings","_mesh"],2,1,4,3,4,6],["cc.ModelLightmapSettings",[],3],["cc.UIMeshRenderer",["node","__prefab"],3,1,4],["64fb7nLWEBKNYNIqgWM9e3g",["m_StrIndex","node","__prefab"],2,1,4],["cc.PrefabInstance",["fileId","prefabRootNode","propertyOverrides"],2,1,9],["CCPropertyOverrideInfo",["value","propertyPath","targetInfo"],1,4],["CCPropertyOverrideInfo",["propertyPath","targetInfo","value"],2,4,8],["cc.TargetInfo",["localID"],2],["ce078wXMcpJL6Arf7BjYntB",["maxLength","gap","node","__prefab","mLayout","mItem"],1,1,4,1,1],["f0aedKZJ+9HxLzKT4Ki31Cg",["_virtual","selectedMode","node","__prefab","tmpNode","pageChangeEvent","renderEvent","selectedEvent"],1,1,4,1,4,4,4],["2f9c2ciPcRH0r1MdLPeXF2g",["node","__prefab"],3,1,4],["cc.Camera",["_name","_projection","_priority","_orthoHeight","_visibility","__prefab","_color"],-2,4,5],["cc.Material",["_states","_defines","_props"],1,12]],[[15,0,2],[8,0,1,2,2],[5,0,1,2,1],[3,0,3,4,5,2],[1,0,1,7,9,6,5,8,3],[1,0,1,7,6,5,8,3],[1,0,2,1,7,6,5,8,4],[2,0,1,6,4,5,7,3],[5,0,1,2,3,1],[3,3,4,5,1],[3,0,1,3,4,5,3],[10,0,1,2,3],[32,0,2],[1,0,1,7,9,6,5,3],[1,0,1,7,6,5,3],[31,0,1,2,2],[1,0,1,9,6,5,3],[1,0,1,9,6,5,8,3],[1,0,1,7,6,5,8,10,3],[5,0,1,1],[19,0,1,1],[3,0,3,4,2],[11,0,1,2,3],[12,0,1,2,4],[13,0,2],[1,0,2,1,7,9,6,5,4],[1,0,1,6,5,8,3],[1,2,3,7,5,3],[1,0,4,1,7,6,5,4],[2,0,1,6,8,4,5,7,3],[2,0,1,8,4,5,7,3],[2,0,3,1,6,4,5,7,9,10,11,4],[2,0,2,1,6,4,5,7,4],[2,0,2,1,6,4,5,4],[14,0,1,2,3,4,5,3],[16,0,1,1],[17,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,2],[8,0,1,2,3,2],[18,0,1,2,3,2],[9,0,2,1,4,5,4],[9,0,1,3,4,5,4],[6,0,1,2,3,4,5,6,2],[6,1,2,1],[6,0,1,2,3,4,5,7,2],[10,1],[20,0,1,2,3,4,1],[21,0,1,2,3,2],[3,0,1,2,3,4,5,4],[3,0,1,2,3,4,4],[22,0,1,2,3,4,5,4],[23,0,1,2,3,4,5,6,5],[24,0,1,1],[7,0,1,5,6,3],[7,0,2,1,3,5,6,5],[7,4,0,1,5,6,4],[25,0,1,2,3,4,5,2],[26,1],[27,0,1,1],[4,0,1,4,5,6,2,3,7,8,9,10,8],[4,0,1,2,3,7,8,9,10,5],[4,0,1,4,6,2,3,7,8,9,7],[4,0,1,4,2,3,7,8,9,6],[4,0,1,4,5,2,3,7,8,9,7],[4,0,1,4,5,2,3,7,8,7],[28,0,1,2,2],[29,0,1,2,2],[30,0,1,2,3],[33,0,1,2,3,4,5,3],[34,0,1,2,3,4,5,6,7,3],[35,0,1,1],[36,0,1,2,3,4,5,6,6],[37,0,1,2,3]],[[[{"name":"T_UI_Book_page_08","rect":{"x":0,"y":0,"width":296,"height":317},"offset":{"x":0,"y":0},"originalSize":{"width":296,"height":317},"rotated":false,"capInsets":[117,0,44,0],"packable":true}],[0],0,[0],[2],[5]],[[[22,".bin",3219909449,[{"primitives":[{"primitiveMode":7,"vertexBundelIndices":[0],"indexView":{"offset":6776,"length":2400,"count":600,"stride":4}}],"vertexBundles":[{"view":{"offset":0,"length":6776,"count":121,"stride":56},"attributes":[{"name":"a_position","format":32,"isNormalized":false},{"name":"a_normal","format":32,"isNormalized":false},{"name":"a_texCoord","format":21,"isNormalized":false},{"name":"a_tangent","format":44,"isNormalized":false},{"name":"a_texCoord1","format":21,"isNormalized":false}]}]},"minPosition",8,[1,-5,0,-5],"maxPosition",8,[1,5,0,5]]],-1],0,0,[],[],[]],[[{"name":"food_type_1","rect":{"x":0,"y":0,"width":78,"height":62},"offset":{"x":0,"y":0},"originalSize":{"width":78,"height":62},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[6]],[[[23,"../LoadOnPlay/Prefab/View/Foodillustration/Page/PageTurning",[{"hash":4150263615,"name":"../LoadOnPlay/Prefab/View/Foodillustration/Page/PageTurning|unlit-vs:vert|unlit-fs:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"ConstantVS","stageFlags":1,"binding":1,"members":[{"name":"angle","type":13,"count":1},{"name":"warp","type":13,"count":1},{"name":"warpPos","type":13,"count":1},{"name":"downward","type":13,"count":1}],"defines":[]},{"name":"Constant","stageFlags":16,"binding":2,"members":[{"name":"mainColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTex","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_TEXTURE"]},{"name":"secTex","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":["USE_TEXTURE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  layout(location = 0) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(set = 1, binding = 1) uniform ConstantVS {\n  float angle;\n  float warp;\n  float warpPos;\n  float downward;\n};\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  layout(location = 0) in vec2 v_uv;\n  layout(set = 1, binding = 3) uniform sampler2D mainTex;\n  layout(set = 1, binding = 4) uniform sampler2D secTex;\n#endif\nlayout(set = 1, binding = 2) uniform Constant {\n  vec4 mainColor;\n};\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv0 = vec2(v_uv.x, 1.0 - v_uv.y);\n    vec4 texColor = texture(mainTex, uv0);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(std140) uniform ConstantVS {\n  float angle;\n  float warp;\n  float warpPos;\n  float downward;\n};\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTex;\n  uniform sampler2D secTex;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n};\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv0 = vec2(v_uv.x, 1.0 - v_uv.y);\n    vec4 texColor = texture(mainTex, uv0);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\n   uniform float angle;\n   uniform float warp;\n   uniform float warpPos;\n   uniform float downward;\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTex;\n  uniform sampler2D secTex;\n#endif\n   uniform vec4 mainColor;\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv0 = vec2(v_uv.x, 1.0 - v_uv.y);\n    vec4 texColor = texture2D(mainTex, uv0);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":202,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":1}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}]},{"hash":3015655390,"name":"../LoadOnPlay/Prefab/View/Foodillustration/Page/PageTurning|unlit-vs:vert|unlit-fs2:frag","blocks":[{"name":"TexCoords","stageFlags":1,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":["USE_TEXTURE"]},{"name":"ConstantVS","stageFlags":1,"binding":1,"members":[{"name":"angle","type":13,"count":1},{"name":"warp","type":13,"count":1},{"name":"warpPos","type":13,"count":1},{"name":"downward","type":13,"count":1}],"defines":[]},{"name":"Constant","stageFlags":16,"binding":2,"members":[{"name":"mainColor","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTex","type":28,"count":1,"stageFlags":16,"binding":3,"defines":["USE_TEXTURE"]},{"name":"secTex","type":28,"count":1,"stageFlags":16,"binding":4,"defines":["USE_TEXTURE"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBias","format":21,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","CC_RECEIVE_SHADOW"]},{"name":"a_dyn_batch_id","format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_vertexId","format":11,"location":13,"defines":["CC_USE_MORPH"]}],"varyings":[{"name":"v_uv","type":14,"count":1,"stageFlags":17,"location":0,"defines":["USE_TEXTURE"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    layout(location = 6) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(location = 7) in vec4 a_matWorld0;\n  layout(location = 8) in vec4 a_matWorld1;\n  layout(location = 9) in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    layout(location = 10) in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    layout(location = 11) in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n#endif\n#if CC_USE_MORPH\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 7) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 8) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 9) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 6) uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(set = 2, binding = 0) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(set = 2, binding = 0) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  layout(location = 0) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(set = 1, binding = 1) uniform ConstantVS {\n  float angle;\n  float warp;\n  float warpPos;\n  float downward;\n};\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  layout(location = 0) in vec2 v_uv;\n  layout(set = 1, binding = 3) uniform sampler2D mainTex;\n  layout(set = 1, binding = 4) uniform sampler2D secTex;\n#endif\nlayout(set = 1, binding = 2) uniform Constant {\n  vec4 mainColor;\n};\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv = vec2(1.0 - v_uv.x, v_uv.y);\n    vec4 texColor = texture(secTex, uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    in vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    layout(std140) uniform CCLocalBatched {\n      highp mat4 cc_matWorlds[10];\n    };\n  #else\n    layout(std140) uniform CCLocal {\n      highp mat4 cc_matWorld;\n      highp mat4 cc_matWorldIT;\n      highp vec4 cc_lightingMapUVParam;\n      highp vec4 cc_localShadowBias;\n    };\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(std140) uniform ConstantVS {\n  float angle;\n  float warp;\n  float warpPos;\n  float downward;\n};\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTex;\n  uniform sampler2D secTex;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n};\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv = vec2(1.0 - v_uv.x, v_uv.y);\n    vec4 texColor = texture(secTex, uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_RECEIVE_SHADOW\n    attribute vec2 a_localShadowBias;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout vec4 In)\n{\n    In = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n}\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n#if !USE_INSTANCING\n  #if USE_BATCHING\n    uniform highp mat4 cc_matWorlds[10];\n  #else\n    uniform highp mat4 cc_matWorld;\n  #endif\n#endif\nvoid CCGetWorldMatrix(out mat4 matWorld)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n      uniform vec4 tilingOffset;\n#endif\n   uniform float angle;\n   uniform float warp;\n   uniform float warpPos;\n   uniform float downward;\nfloat cubicIn(float k) {\n  return k * k * k;\n}\nvec4 vert () {\n  vec4 position;\n  CCVertInput(position);\n  mat4 matWorld;\n  CCGetWorldMatrix(matWorld);\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n    #if SAMPLE_FROM_RT\n      v_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n    #endif\n  #endif\n  position += vec4(5, 0, 0, 0);\n  float r = radians(angle);\n  float s = sin(r);\n  float c = cos(r);\n  mat4 rotate = mat4(\n    c, s, 0, 0,\n    -s, c, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  );\n  float rangeF = clamp((1.0 - abs(90.0 - angle) / 90.0), 0.0, 1.0);\n  position.y += -warp * sin(position.x * 0.4 - warpPos * position.x) * rangeF;\n  position.x -= rangeF * position.x * downward;\n  position.z -= cubicIn(v_uv.x) * 3.0 * s;\n  position = rotate * position;\n  position += vec4(-5, 0, 0, 0);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = ACESToneMap(color.rgb);\n  #endif\n  color.rgb = sqrt(color.rgb);\n  return color;\n}\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTex;\n  uniform sampler2D secTex;\n#endif\n   uniform vec4 mainColor;\nvec4 frag () {\n  vec4 o = mainColor;\n  #if USE_TEXTURE\n    vec2 uv = vec2(1.0 - v_uv.x, v_uv.y);\n    vec4 texColor = texture2D(secTex, uv);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    o *= texColor;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":202,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":1}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"SAMPLE_FROM_RT","type":"boolean","defines":["USE_TEXTURE"]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}]}],[{"passes":[{"program":"../LoadOnPlay/Prefab/View/Foodillustration/Page/PageTurning|unlit-vs:vert|unlit-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":2},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainTex":{"value":"grey","type":28},"secTex":{"value":"grey","type":28},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"angle":{"type":13,"value":[0],"editor":{"slide":true,"step":1,"range":[0,180]}},"warp":{"type":13,"value":[0],"editor":{"slide":true,"step":0.1,"range":[0,10]}},"warpPos":{"type":13,"value":[0],"editor":{"slide":true,"step":0.01,"range":[0,1]}},"downward":{"type":13,"value":[0],"editor":{"slide":true,"step":0.01,"range":[0,1]}}}},{"propertyIndex":0,"program":"../LoadOnPlay/Prefab/View/Foodillustration/Page/PageTurning|unlit-vs:vert|unlit-fs2:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"rasterizerState":{"cullMode":1},"properties":{"tilingOffset":{"type":16,"value":[1,1,0,0]},"mainTex":{"value":"grey","type":28},"secTex":{"value":"grey","type":28},"mainColor":{"linear":true,"type":16,"value":[1,1,1,1],"editor":{"type":"color"}},"angle":{"type":13,"value":[0],"editor":{"slide":true,"step":1,"range":[0,180]}},"warp":{"type":13,"value":[0],"editor":{"slide":true,"step":0.1,"range":[0,10]}},"warpPos":{"type":13,"value":[0],"editor":{"slide":true,"step":0.01,"range":[0,1]}},"downward":{"type":13,"value":[0],"editor":{"slide":true,"step":0.01,"range":[0,1]}}}}]}]]],0,0,[],[],[]],[[{"name":"banner_bg","rect":{"x":0,"y":0,"width":510,"height":103},"offset":{"x":0,"y":0},"originalSize":{"width":510,"height":103},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[7]],[[{"name":"UI_bg_3","rect":{"x":0,"y":0,"width":215,"height":186},"offset":{"x":0,"y":0},"originalSize":{"width":215,"height":186},"rotated":false,"capInsets":[61,65,70,68],"packable":true}],[0],0,[0],[2],[8]],[[{"name":"T_UI_Book_sort_10","rect":{"x":0,"y":0,"width":682,"height":123},"offset":{"x":0,"y":0},"originalSize":{"width":682,"height":123},"rotated":false,"capInsets":[204,0,44,0],"packable":true}],[0],0,[0],[2],[9]],[[{"name":"T_UI_Book_sort_01","rect":{"x":0,"y":0,"width":70,"height":56},"offset":{"x":0,"y":0},"originalSize":{"width":70,"height":56},"rotated":false,"capInsets":[57,0,0,0],"packable":true}],[0],0,[0],[2],[10]],[[{"name":"progress_bar_2","rect":{"x":3,"y":3,"width":525,"height":29},"offset":{"x":0,"y":0},"originalSize":{"width":531,"height":35},"rotated":false,"capInsets":[101,0,107,0],"packable":true}],[0],0,[0],[2],[11]],[[{"name":"pipe3","rect":{"x":0,"y":0,"width":82,"height":46},"offset":{"x":0,"y":0},"originalSize":{"width":82,"height":46},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[12]],[[{"name":"progress_bar_1","rect":{"x":0,"y":0,"width":531,"height":35},"offset":{"x":0,"y":0},"originalSize":{"width":531,"height":35},"rotated":false,"capInsets":[25,0,24,0],"packable":true}],[0],0,[0],[2],[13]],[[[24,"FoodillustrationView"],[16,"FoodillustrationView",33554432,[-18,-19,-20],[[2,-3,[0,"57IuXQlhRDbp0caFe8FKGk"],[5,1080,1920]],[35,-4,[0,"068IXivRxBEqI+sJr2c52K"]],[36,false,-17,[0,"77RCQ42pJE17NOaiYDskKX"],-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5]],[37,"edoDVC6JlAsIvEEpzivci3",-2,0,[-1]]],[17,"pageContent",1,[-22,-23,-24,-25,-26,-27,-28,-29,-30,-31,-32,-33,-34],[[2,-21,[0,"b7Bh9RRXRINY4pOUfQ0Bfx"],[5,988,1420]]],[1,"ccTqNUGvlJU6F9pyTT14nz",1,0],[1,-30,5,1]],[25,"content",512,33554432,1,[-37,2,-38,-39,-40],[[2,-35,[0,"7clHGa2VVI0LJuvUCwVgFV"],[5,1080,1524]],[39,8,757.5,100,-36,[0,"72a5x8YQtM3pPHx9xVOuVG"]]],[1,"046wCqHpRFAKFkwYYmbyDb",1,0]],[16,"bg2",1,[-46,-47,-48,-49],[[2,-41,[0,"3eNitXCjFCt4jlXPhymxb4"],[5,350,350]],[41,1,-44,[0,"e8DZxO2zNODbtLoms6Kgi7"],[[11,"db5e5YnM+5IiJycJF6Y0BE/","c_Click",-43]],[4,4294967295],[4,4291348680],-42],[20,-45,[0,"4dr5ORUk9KQY5n832HwrP2"]]],[1,"ebk7rzIMZJHIlCefitTMFg",1,0]],[4,"foodItem1",1,2,[-55,4],[[2,-50,[0,"56CDiwixZLX7GDRzum220R"],[5,350,350]],[45,-54,[0,"aaJJ57TcZLsKR8W5+h0xe2"],-53,-52,-51]],[1,"8chnb2f/FEg4UlEmdme2YX",1,0],[1,-200,224,0]],[17,"item1",33554432,[-60,-61],[[2,-56,[0,"b1FRukadpGA7YZAvUO+xWI"],[5,131.33,140]],[42,-57,[0,"4eInd0fJxKEbp4ntY1NeYR"]],[46,1,-59,[0,"e5gDawcUhNCaQy/w0t7aay"],-58]],[1,"dbat+ePXpBaIt5vmKusFFC",1,0],[1,-319.335,0,0]],[4,"lab",1,2,[-63,-64,-65,-66],[[19,-62,[0,"06OwOEdotKlqnDNfe2VtFP"]]],[1,"8fet1Jk7xDnYkpq7FhLXMj",1,0],[1,30,-5,0]],[29,"PagePointCom",1,2,[-69,-70],[[[2,-67,[0,"2aTPlunMBJY6XxJGvSw27U"],[5,22,21]],-68],4,1],[1,"dauJND83RHXoq0SeFzgFU3",1,0],[1,6.538,-659.201,0]],[4,"item",1,8,[-72,-73],[[2,-71,[0,"836kGpJ/FOJoMBRfc0BUBQ"],[5,17,17]]],[1,"deNCo5ni5M47XuOKV2c2Wd",1,0],[1,0,2.607,0]],[4,"ProgressBar",1,2,[-78],[[2,-74,[0,"4fA5EA6YJOkJ5J8iC+51co"],[5,531,35]],[47,1,2,0.5,-75,[0,"84nL3wThNG5Zu3LYeGBCnO"],15],[49,false,531,0,-77,[0,"80PS6numtJyI2sT/0VD5Qk"],-76]],[1,"1aOLZmIBFOA5KYx9+UOdOo",1,0],[1,49.844,467.532,0]],[30,"pageList",33554432,[-83],[[[2,-79,[0,"ea+rGfRktDFJ/GbnOHdQXn"],[5,770,150]],[50,0.23,0.75,false,false,-81,[0,"d4/9Ky2O1FxrQwJd+FQ2x1"],-80],-82],4,4,1],[1,"b2mKP68TBAxLRT+NyRvZl9",1,0],[1,-39,-785,0]],[13,"view",33554432,11,[-87],[[2,-84,[0,"fffMGEcoBID7fFnYykv+6S"],[5,770,150]],[51,-85,[0,"easlhz+llL3ZMawosiULIz"]],[40,45,800,150,-86,[0,"191A/mRrJNS4gJ0tmWIxKU"]]],[1,"1fYDMtB/hHmZ1YXgX0lvm/",1,0]],[13,"content",33554432,12,[6],[[2,-88,[0,"c2Z5jGtpVELLJjuGe61VlK"],[5,770,150]],[52,1,-2,-89,[0,"e5qODuYeNB8aGK5+Qs6FJi"]]],[1,"02PBc6ChdATLYvtyULMGuz",1,0]],[4,"bg2",33554432,6,[-92],[[8,-90,[0,"afocoHQ/5IaZEcxDOekEqo"],[5,130,112],[0,0.5,1]],[9,-91,[0,"88vbRYgyNCNr8ms3eW2jFg"],20]],[1,"37mI9daM5Is5RNs7c7mCCP",1,0],[1,0,75,0]],[26,"closeButton",33554432,[[2,-93,[0,"2aiLJQKzBImblYAmZCqrtC"],[5,110,110]],[9,-94,[0,"30Fzdgk/lFUaKmUY+NjDEK"],21],[43,1,-95,[0,"374wBYjLdIp6gDYOGdYKiY"],[[11,"3cf5dK5T/pOha3nl0sjO8St","clickClose",1]],[4,4294967295],[4,4291348680],22],[20,-96,[0,"a2htf3IkNA570KDxJ8ccRB"]]],[1,"6aHg0k8dlMxKBVnA0q9Kgl",1,0],[1,462,732,0]],[31,"page",false,33554432,3,[[[55,"Plane<ModelComponent>",-97,[0,"e4zcnm24NMlZCPn3HxGooN"],[23],[56],24],[57,-98,[0,"f3MEzbNfpKOo2LRtdUq6we"]],[19,-99,[0,"39esQQDZJPqaepv9qdnVSv"]],-100],4,4,4,1],[1,"2cM1wuUfhLdY/BO2wPiAcl",1,0],[1,-32,6.323,0],[3,0.7071067811865475,0,0,0.7071067811865476],[1,98,142,142],[1,90,0,0]],[18,"typeIcon",1,2,[[2,-101,[0,"31vWgPERZGA4KFl9PhSFRG"],[5,78,62]],[3,1,-102,[0,"61msngHIJH8pkoGtS7Qz46"],9]],[1,"d6yCUz/EpDw7n99ypfbrmU",1,0],[1,-280,470,0],[1,0.91,0.91,1]],[13,"bg1",1,5,[-105],[[2,-103,[0,"4bpctignpMKago7R+Rp2/Q"],[5,296,317]],[3,1,-104,[0,"45qSHPb91J3Jvw8iM66ylO"],11]],[1,"10aeE4wGtFdYcysj04UN82",1,0]],[14,"iconBg",1,4,[[2,-106,[0,"90qzZMHUZNI5g9curbNW6I"],[5,296,317]],[3,1,-107,[0,"dcRwcCCGRJhryurXCxtRKy"],12]],[1,"e9AeR6HB5OQoEv01uw3+Bu",1,0]],[18,"teseIcon",1,4,[[2,-108,[0,"cbJbeeJZxOd45uc6Ibifr/"],[5,138,78]],[21,1,-109,[0,"9cRXBmc5VH+4Gqlxlg5T+f"]]],[1,"8eOfa6B/BPQriqXMCv+3/4",1,0],[1,-94,140,0],[1,0.8,0.8,1]],[5,"icon",1,4,[[2,-110,[0,"67BVLOLp5H5r0cht6ipFXv"],[5,220,110]],[21,1,-111,[0,"62oj07XA1AUYcRIw7C18eb"]]],[1,"12bbhKhpBHdLznhmiw+hY9",1,0],[1,0,6,0]],[5,"title",1,7,[[2,-112,[0,"14h3uIxA5F34Cws8lAVtJ4"],[5,420,68]],[58,"BOTTOM  HOP",68,68,68,2,false,2,-113,[0,"9cv1mg7u9Fm61sENkX7MPa"],[4,4292076522],16],[64,"36_1",-114,[0,"74DyswxaVFcKGbwyhM8Wwa"]]],[1,"92CIaFZhVKeK428JdPyikB",1,0],[1,-31,625,0]],[7,"typeLab",1,7,[[[2,-115,[0,"c68pGoTt5OuYiZLakcMjog"],[5,127.01,40]],-116],4,1],[1,"9egCHY/uxA/Ju0/LmGHDk4",1,0],[1,-307,406,0]],[4,"content",33554432,3,[11,15],[[2,-117,[0,"c1sy7OCjlGLofr6x0sz3pg"],[5,875,1180]]],[1,"9fQnc20lZE35Z9BqBTpVuk",1,0],[1,7,5,0]],[4,"bg1",33554432,6,[-120],[[8,-118,[0,"61u3BovzFMTbuzMTcqnjkj"],[5,107,100],[0,0.5,1]],[9,-119,[0,"c5HftyioNGV42PIMEIpsto"],18]],[1,"ee6EzdOARDGpib86NrrtZl",1,0],[1,0,75,0]],[27,512,{},1,[38,"62lW6binVJTrVho/b0CWzF",-121,[65,"eefHHJqelKOrcNAF78ul8j",1,[[66,"mask",["_name"],[12,["62lW6binVJTrVho/b0CWzF"]]],[15,["_lpos"],[12,["62lW6binVJTrVho/b0CWzF"]],[1,0,0,0]],[15,["_lrot"],[12,["62lW6binVJTrVho/b0CWzF"]],[3,0,0,0,1]],[15,["_euler"],[12,["62lW6binVJTrVho/b0CWzF"]],[1,0,0,0]]]],0]],[6,"bg2",512,33554432,3,[[2,-122,[0,"7c+SqFTkBAp4E9nTnK8cy+"],[5,1080,1524]],[10,1,0,-123,[0,"78CYGPVyVAa4D1lKiUXRX4"],1]],[1,"93sU4MzRJEU4T0YZwnVlkI",1,0],[1,-45,-12,0]],[6,"bg1",512,1,2,[[2,-124,[0,"c1sy7OCjlGLofr6x0sz3pg"],[5,988,1443]],[10,1,0,-125,[0,"ddpKXLwKZLKIGkpvSASS7o"],2]],[1,"de4urouBJA06MWdpQCvMry",1,0],[1,4,-21,0]],[5,"banner_bg",1,2,[[2,-126,[0,"9dr4H3d/FPBZuKlfmO2Y2p"],[5,510,103]],[3,1,-127,[0,"974kV4vZFPG6gRXgSenEgW"],3]],[1,"3c8+zPNzJJfqnqVyE7u7xU",1,0],[1,0,604,0]],[5,"bg3",1,2,[[2,-128,[0,"0dwjIaHIxG9ZlPdlciPuQ9"],[5,682,123]],[10,1,2,-129,[0,"f9LEQ3VopI/ZIfxVqgW9Yc"],4]],[1,"77L0NtGghNraBkO6o+4dAa",1,0],[1,0,470,0]],[6,"pipe3",512,1,2,[[2,-130,[0,"85nLigsnRP3aa75OESDaoX"],[5,82,46]],[3,1,-131,[0,"e1Jn36J5tJJbaROdSZOl5X"],5]],[1,"757Nmc/RFAaLOgIVG7F34c",1,0],[1,-469,458,0]],[6,"pipe4",512,1,2,[[2,-132,[0,"36nExTr35EtYvI4POB6uGJ"],[5,82,46]],[3,1,-133,[0,"36SalzdaBMS69w+uMFhgmM"],6]],[1,"73MQoVhMpEMoToHQz0sdEH",1,0],[1,-469,385,0]],[6,"pipe5",512,1,2,[[2,-134,[0,"bb6i8oh59DzYGJ9Jrdaoot"],[5,82,46]],[3,1,-135,[0,"2bKJMvWoFP0Kntdq+KhdHu"],7]],[1,"eef5EPsWVMyZ0XMhgZj+rX",1,0],[1,-469,-420,0]],[6,"pipe6",512,1,2,[[2,-136,[0,"3dkgPLESdOB6VYP+uTF8md"],[5,82,46]],[3,1,-137,[0,"d9UE31TKpP07QXL7BwEnpy"],8]],[1,"75gRdWTc1O/rMUVpQ303VV",1,0],[1,-469,-498,0]],[5,"lab",1,18,[[2,-138,[0,"58tVe6mhVJv6ndg1BQAuhk"],[5,102.3,40]],[59,"??????",40,false,2,-139,[0,"f5TcV/em5BEqGJT2aznrKB"],[4,4284506724],10]],[1,"c7H6chsA9CLKuHZg6x1E8u",1,0],[1,0,-124,0]],[7,"nameLab",1,4,[[[2,-140,[0,"f2KCAr/U5L46BGeLXyV2lB"],[5,280,50.4]],-141],4,1],[1,"25eZA/i6pBz74k+sOa3v2B",1,0],[1,0,-118.491,0]],[32,"itemLayout",512,1,2,[[[2,-142,[0,"35J4mB+K1DfYKZqwsrc/Or"],[5,800,1000]],-143],4,1],[1,"dcX8g6/flKCoa79WjGMhVu",1,0],[1,25,-141,0]],[14,"1",1,9,[[2,-144,[0,"fcWFruZXBALIUzJkAu4df7"],[5,17,17]],[10,1,2,-145,[0,"00m66YmehO55fkZrqSdrGp"],13]],[1,"1fFXMu7H5P3qKDI9k3A2dy",1,0]],[14,"2",1,9,[[2,-146,[0,"2c3N1fgq9CB6Vuwrp3b7pS"],[5,17,17]],[10,1,2,-147,[0,"7bQ34GjvFD9Ksu/MC1uGAy"],14]],[1,"fein264zRA14CKz+leB6I3",1,0]],[33,"layout",512,1,8,[[[2,-148,[0,"2fel1UtIpAKoSDYLFHM+pI"],[5,526,60]],-149],4,1],[1,"95DLPlpe5BWopFQmodPP6q",1,0]],[7,"Bar",1,10,[[[8,-150,[0,"67HSqr7n5L/p2L0O4aj/j4"],[5,531,35],[0,0,0.5]],-151],4,1],[1,"89u1Zv+fNJYolQdukN/UC6",1,0],[1,-265.5,0,0]],[48,3,2,1,41,[0,"aeE9DF70dJL6nM1TK5eRbB"]],[7,"progressLab1",1,7,[[[8,-152,[0,"b1hNk582BFFLuUVH7C61F5"],[5,26.7,30],[0,1,0.5]],-153],4,1],[1,"e6quIToUFFMZ5PDkqST6E1",1,0],[1,24.766,472.417,0]],[7,"progressLab2",1,7,[[[8,-154,[0,"c88RX2gjhEObXScu+SZxfL"],[5,25.67,30],[0,0,0.5]],-155],4,1],[1,"29OWtg/OxG4rkRjI6hcv6H",1,0],[1,24.766,472,0]],[28,"tempContent",false,33554432,3,[[2,-156,[0,"7clHGa2VVI0LJuvUCwVgFV"],[5,1000,1300]]],[1,"0cnNsXaOlM/KW2Uqzj+w3C",1,0]],[5,"icon",33554432,25,[[2,-157,[0,"99+N06WfFGrJieVViGDLWC"],[5,70,56]],[9,-158,[0,"37eJONwJ1BRpw9zdg+g2ma"],17]],[1,"86tE4xOv9Oc4zix71NdUB2",1,0],[1,-1,-52,0]],[5,"icon",33554432,14,[[2,-159,[0,"48EdN2Is1PfLoepLVb+GZf"],[5,78,62]],[9,-160,[0,"felODbCV9KU6Fx39kUBoi5"],19]],[1,"8eClp/DcNNJ59oqUG3iJWv",1,0],[1,-1,-52,0]],[60,"Beef spaghetti",38,38,2,false,2,36,[0,"ecSTztelZJLoydO9aHc+P4"],[4,4281560995]],[53,3,-40,55,-20,37,[0,"95wN/1GWVHe4VhosyNg1Pk"]],[54,1,1,50,40,[0,"58Fdq9IgxACK7CGA17bVJs"]],[67,526,50,8,[0,"1fvPQ/TgJAkLArdqu5BO8L"],50,9],[61,"BOTTM HOP",32,32,false,2,23,[0,"a4o+lxOT1Gh4dmgZLuxKP1"],[4,4284242330]],[62,"21",34,34,30,false,2,43,[0,"47ssyq0KpMu65cXDDnbsdn"],[4,4284216831]],[63,"/8",34,34,30,false,2,44,[0,"10fHlD2+1KJbwSvlyV06dI"]],[68,false,1,11,[0,"c09w0/kCdBLauWBpZZqrtw"],6,[44],[11,"3cf5dK5T/pOha3nl0sjO8St","onListVRender",1],[11,"3cf5dK5T/pOha3nl0sjO8St","onListSelected",1]],[69,16,[0,"76vWWyntxHZKqGSDfAzsyW"]],[70,"Camera<CameraComponent>",0,1073741825,960,1,[0,"5egRorH3VCs5oreqXjNBVL"],[4,0]],[34,"Camera",1,1,[57],[1,"98bEKUw7BE3JeryeUkZD9k",1,0],[1,0,0,1000]]],0,[0,-1,26,0,5,1,0,0,1,0,0,1,0,6,45,0,7,56,0,8,51,0,9,55,0,10,42,0,11,52,0,12,17,0,13,54,0,14,53,0,15,23,0,16,49,0,17,5,0,0,1,0,-1,26,0,-2,3,0,-3,58,0,0,2,0,-1,28,0,-2,29,0,-3,30,0,-4,31,0,-5,32,0,-6,33,0,-7,34,0,-8,17,0,-9,5,0,-10,37,0,-11,8,0,-12,10,0,-13,7,0,0,3,0,0,3,0,-1,27,0,-3,45,0,-4,24,0,-5,16,0,0,4,0,18,19,0,19,5,0,0,4,0,0,4,0,-1,19,0,-2,20,0,-3,21,0,-4,36,0,0,5,0,20,48,0,21,21,0,22,20,0,0,5,0,-1,18,0,0,6,0,0,6,0,23,14,0,0,6,0,-1,25,0,-2,14,0,0,7,0,-1,22,0,-2,23,0,-3,43,0,-4,44,0,0,8,0,-2,51,0,-1,9,0,-2,40,0,0,9,0,-1,38,0,-2,39,0,0,10,0,0,10,0,24,42,0,0,10,0,-1,41,0,0,11,0,25,13,0,0,11,0,-3,55,0,-1,12,0,0,12,0,0,12,0,0,12,0,-1,13,0,0,13,0,0,13,0,0,14,0,0,14,0,-1,47,0,0,15,0,0,15,0,0,15,0,0,15,0,0,16,0,0,16,0,0,16,0,-4,56,0,0,17,0,0,17,0,0,18,0,0,18,0,-1,35,0,0,19,0,0,19,0,0,20,0,0,20,0,0,21,0,0,21,0,0,22,0,0,22,0,0,22,0,0,23,0,-2,52,0,0,24,0,0,25,0,0,25,0,-1,46,0,5,26,0,0,27,0,0,27,0,0,28,0,0,28,0,0,29,0,0,29,0,0,30,0,0,30,0,0,31,0,0,31,0,0,32,0,0,32,0,0,33,0,0,33,0,0,34,0,0,34,0,0,35,0,0,35,0,0,36,0,-2,48,0,0,37,0,-2,49,0,0,38,0,0,38,0,0,39,0,0,39,0,0,40,0,-2,50,0,0,41,0,-2,42,0,0,43,0,-2,53,0,0,44,0,-2,54,0,0,45,0,0,46,0,0,46,0,0,47,0,0,47,0,26,1,2,4,3,4,4,5,6,4,13,11,4,24,15,4,24,56,27,57,57,0,58,160],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,42,52,53,54],[28,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,3,1,1,1,1,1,29,-1,30,3,1,3,3,3],[14,15,16,17,18,1,1,1,1,2,0,19,20,21,22,23,24,25,26,2,27,3,3,28,29,0,30,0,0,0]],[[[71,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}},{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true},{}],[[[{"warp":3.1,"warpPos":0.133,"downward":0.371},"mainTex",6,0,"secTex",6,1],{}],11,0]]],0,0,[0,0,0],[31,32,33],[4,4,31]],[[{"name":"T_UI_Book_page_11","rect":{"x":0,"y":0,"width":107,"height":100},"offset":{"x":0,"y":0},"originalSize":{"width":107,"height":100},"rotated":false,"capInsets":[107,0,0,0],"packable":true}],[0],0,[0],[2],[32]],[[{"name":"T_UI_Book_page_09","rect":{"x":0,"y":0,"width":296,"height":317},"offset":{"x":0,"y":0},"originalSize":{"width":296,"height":317},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[33]],[[{"name":"point_2","rect":{"x":0,"y":0,"width":17,"height":17},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":17},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[34]],[[{"name":"point_1","rect":{"x":0,"y":0,"width":17,"height":17},"offset":{"x":0,"y":0},"originalSize":{"width":17,"height":17},"rotated":false,"capInsets":[0,0,0,0],"packable":true}],[0],0,[0],[2],[35]],[[{"name":"T_UI_Book_page_10","rect":{"x":0,"y":0,"width":130,"height":112},"offset":{"x":0,"y":0},"originalSize":{"width":130,"height":112},"rotated":false,"capInsets":[113,0,0,0],"packable":true}],[0],0,[0],[2],[36]]]]
